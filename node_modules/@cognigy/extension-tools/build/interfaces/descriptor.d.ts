export interface INodeDescriptor {
    _id?: TMongoId;
    type: string;
    parentType?: string;
    defaultLabel: string | INodeFieldTranslations;
    summary?: string | INodeFieldTranslations;
    appearance: INodeAppearance;
    behavior?: INodeBehavior;
    constraints?: INodeConstraints;
    dependencies?: INodeDependencies;
    fields?: INodeField[];
    function?: TNodeFunction;
    /** Defines how the preview should be generated for nodes using this descriptor */
    preview?: INodePreview;
    /**
     * Tags which allow searching individual Nodes
     *
     * The following tags will put the Node
     * into the distinct "function tabs":
     *
     * - basic
     * - logic
     * - message
     * - profile
     * - service
     * - nlu
     * - data
     * */
    tags?: TNodeTagType[];
    /** Definition of tokens this node might fill */
    tokens?: ISnippet[];
    /** Sections which allow to group multiple fields */
    sections?: INodeSection[];
    /** The form defines how fields and sections should be render in order */
    form?: INodeFieldAndSectionFormElement[];
}
export declare type TMongoId = any;
export interface INodeFieldAndSectionFormElement {
    /** A key either pointing to a 'field -> key' or 'section -> key' */
    key: string;
    /** The type of the pointer, either 'field' or 'section' */
    type: "field" | "section";
}
export interface INodeSection {
    /** Unique identifier for this section within all sections of a descriptor, e.g. 'authentication' */
    key: string;
    /** Human readable lable of the seciton, e.g. 'Authentication' */
    label: string | INodeFieldTranslations;
    /** Condition whether this section should be rendered */
    condition?: TNodeFieldCondition;
    /** Whether the sections should be collapsed by default (default: false) */
    defaultCollapsed: boolean;
    /** The fields that should be grouped in this section, points to 'key' of node-fields */
    fields: string[];
}
export interface INodeFieldTranslations {
    default: string;
    enUS?: string;
    deDE?: string;
    esES?: string;
    jaJP?: string;
    koKR?: string;
}
export interface ISnippet {
    /**
     * The label (name) of the snippet.
     */
    label: string;
    /**
     * The type of the snippet
     * based on what the snippet accesses
     * (profile, input or context)
     */
    type: TSnippetType;
    /**
     * The script the snippet executes
     */
    script: string;
}
export declare const snippetTypes: readonly ["profile", "input", "context", "custom", "answer", "flow-output", "flow-input"];
export declare type TSnippetType = typeof snippetTypes[number];
declare type TCognigyNodeTagType = "basic" | "logic" | "message" | "profile" | "service" | "nlu" | "data";
export declare type TNodeTagType = TCognigyNodeTagType | string;
export interface INodePreview {
    type: "text" | "image" | "custom";
    key: string;
}
declare const nodeFieldTypes: readonly ["text", "rule", "json", "checkbox", "time", "date", "datetime", "select", "typescript", "xml", "textArray", "chipInput", "cognigyText", "toggle", "slider", "number", "daterange", "connection", "say", "condition", "adaptivecard"];
export declare type TNodeFieldType = typeof nodeFieldTypes[number];
export interface INodeField {
    type: TNodeFieldType;
    key: string;
    label: string | INodeFieldTranslations;
    condition?: TNodeFieldCondition;
    defaultValue?: any;
    description?: string | INodeFieldTranslations;
    params?: object;
    /**
     * Used to dynamically resolve options for a select-field via a custom resolver function.
     * Resolved options will override the statically defined options
     */
    optionsResolver?: INodeOptionsResolver;
}
export declare type TComparableValue = string | number | boolean;
export declare type TNodeFieldCondition = INodeFieldSingleCondition | INodeFieldANDCondition | INodeFieldORCondition;
export interface INodeFieldSingleCondition {
    /** The key of the Field whose value should be matched */
    key: string;
    /** The expected value(s) that make this condition match */
    value: TComparableValue | TComparableValue[];
    /** If this is true, the condition result will be inverted */
    negate?: boolean;
    or?: never;
    and?: never;
}
export interface INodeFieldANDCondition {
    key?: never;
    value?: never;
    negate?: never;
    or?: never;
    /** Nested conditions are supported in version 4.1.4 and up of the Cognigy AI */
    and: TNodeFieldCondition[];
}
export interface INodeFieldORCondition {
    key?: never;
    value?: never;
    negate?: never;
    /** Nested conditions are supported in version 4.1.4 and up of the Cognigy AI */
    or: TNodeFieldCondition[];
    and?: never;
}
export interface INodeDependencies {
    /** A list of Node types */
    children: string[];
}
export interface INodeDefaults extends Partial<Pick<IChartNode, TDefaultNodeFields>> {
    config: {
        [key: string]: unknown;
    };
}
export interface IChartNode {
    _id: TMongoId;
    referenceId: string;
    type: string;
    extension: string;
    label: string;
    comment: string;
    isCollapsed: boolean;
    isEntryPoint: boolean;
    isDisabled: boolean;
    config: {
        [key: string]: any;
    };
    chartReference: TMongoId;
    resourceReference: TMongoId;
    projectReference: TMongoId;
    organisationReference: TMongoId;
}
export declare const defaultNodeFields: readonly ["label", "comment", "isDisabled", "isEntryPoint", "isCollapsed"];
export declare type TDefaultNodeFields = typeof defaultNodeFields[number];
export interface INodeBehavior {
    stopping?: boolean;
    entrypoint?: boolean;
}
export declare type INodeConstraint = {
    /** A list of Node types */
    whitelist?: string[];
    /** A list of Node types */
    blacklist?: string[];
};
export interface INodeConstraints {
    editable?: boolean;
    deletable?: boolean;
    creatable?: boolean;
    collapsable?: boolean;
    childFlowCreatable?: boolean;
    movable?: boolean;
    placement: {
        predecessor?: INodeConstraint;
        successor?: INodeConstraint;
        children?: INodeConstraint;
    };
}
export interface INodeAppearance {
    color?: string;
    textColor?: string;
    contrastTextColor?: string;
    showIcon?: boolean;
    variant?: "regular" | "mini" | "hexagon";
}
export declare type TNodeFunction = (params: INodeFunctionBaseParams) => Promise<void>;
export interface INodeFunctionBaseParams {
    cognigy: INodeExecutionCognigyObject;
    childConfigs: TNodeChildConfigs[];
    config: object;
    nodeId: string;
}
export interface INodeExecutionCognigyObject extends IExecutionObjects {
    api: INodeExecutionAPI;
}
export interface IExecutionObjects {
    input: ICognigyInputProperties;
    context: {
        [key: string]: any;
    };
    profile: ICognigyContactProfileProperties;
}
export interface INodeExecutionAPI extends Omit<IActions, "parseCognigyScriptCondition" | "think" | "addConditionalEntrypoint"> {
    setNextNode?: (nodeId: string) => void;
    resetNextNodes?: () => void;
    stopExecution?: () => void;
    parseCognigyScriptCondition?: (condition: string) => string;
    think?: (text: string, data: {
        [key: string]: any;
    }) => void;
    getExecutionAmount?: (nodeId: string) => number;
    resetExecutionAmount?: (nodeId: string) => void;
    setExecutionAmount?: (nodeId: string, value: number) => void;
    executeFlow?: (config: IExecuteFlowNodeConfig) => Promise<void>;
    addConditionalEntrypoint?: (addConditionalEntrypointParams: IAddConditionalEntrypointParams) => void;
}
export interface IExecuteFlowNodeConfig {
    flowId: string;
    nodeId: string;
    parseIntents?: boolean;
    parseKeyphrases?: boolean;
    absorbContext?: boolean;
}
export interface IActions {
    think?: (nodeId: string) => (text: string, data: any) => void;
    output?: (text: string, data: any) => void;
    say?: (text: string, data?: any) => void;
    switchFlow?: (id: string, text: string, data: any, version?: number, absorbContext?: boolean) => void;
    setContext?: (key: string, value: any) => void;
    setContextAndPersist?: (key: string, value: any) => Promise<void>;
    addToContext?: (key: string, value: any, mode: string) => void;
    updateProfile?: (key: string, value: any) => Promise<any>;
    deactivateProfile?: (deleteData: boolean) => Promise<any>;
    deleteProfile?: () => Promise<any>;
    activateProfile?: () => Promise<any>;
    mergeProfile?: (contactId: string) => Promise<any>;
    removeFromContext?: (key: string, value: string, mode: string) => void;
    getContext?: (key: string) => any;
    getSystemContext?: (key: string) => any;
    setSystemContext?: (key: string, value: any) => void;
    setState?: (state: string) => void;
    getState?: () => string;
    deleteContext?: (key: string) => void;
    deleteSystemContext?: (key: string) => void;
    getCache?: (key: string) => void;
    setCache?: (key: string, val: any) => void;
    getLastTopic?: (type: any, age: number) => void;
    setLastTopic?: (text: string, type: any, age: number) => void;
    log?: (level: string, text: string) => void;
    resetContext?: () => Promise<object>;
    resetState?: () => Promise<string>;
    completeGoal?: (key: string) => void;
    checkThink?: (id: string) => boolean;
    addLexiconKeyphrase?: (lexicon: string, keyphrase: string, tags: Array<string>, synonyms: Array<string>, data?: Object) => void;
    setKeyphrase?: (keyphrase: string, tags: string[], synoyms: string[]) => void;
    setTimezoneOffset?: (offset: number | string) => void;
    resetFormBrain?: () => Promise<void>;
    parseCognigyScriptText?: (executionObjects: IExecutionObjects) => (text: string) => string;
    parseCognigyScriptCondition?: (executionObjects: IExecutionObjects, nodeId: string) => (condition: string) => string;
    emitEvent?: (event: string, data: any) => void;
    setForwardDatesOnly?: (value: boolean) => void;
    executeCognigyNLU?: (text: string, data: any, inputId: string) => Promise<INLProperties>;
    requestHandover?: (text: string, cancel: string, userId: string, sessionId: string, requestHandover: string, inputAnalyticsData: any) => void;
    handover?: (handoverParams: IHandoverParams) => Promise<void>;
    sendHttpRequest?: (httpRequestParams: IHttpRequestParams) => Promise<void>;
    executeCodeInSecureContext?: (codeParams: ICodeParams) => void;
    setSensitiveLoggingSettings?: (settings: ISensitiveLoggingSettings, traceId: string) => void;
    addConditionalEntrypoint?: (actions: IActions, flowId: string) => (addConditionalEntrypointParams: IAddConditionalEntrypointParams) => void;
}
export interface IHandoverParams extends INodeFunctionBaseParams {
    config: {
        text: string;
        cancelIntent: string;
        unavailable: string;
        unsupportedChannel: string;
        quickReply: string;
    };
}
export interface IHttpRequestParams extends INodeFunctionBaseParams {
    config: {
        type: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
        url: string;
        headers: JSON;
        payloadIsJSON: boolean;
        payload: string;
        contextKey: string;
        authType: string;
        authParameters: any;
        async: boolean;
        cache: boolean;
        cacheExpiry: number;
        storeResponseHeaders: boolean;
    };
}
export interface ICodeParams extends INodeFunctionBaseParams {
    config: {
        code: string;
    };
}
export interface INLProperties extends ICognigyNLPProperties {
    timeReference?: any;
    organisation?: string;
    grammarComponents?: {
        nouns?: any;
        verbs?: any;
        adjectives?: any;
        adverbs?: any;
    };
    result?: any;
    flowId?: string;
    URLToken?: string;
    ngramProcessText?: any;
}
export interface ICognigyNLPProperties {
    /** The original text of the user */
    text?: string;
    /** The original data of the user */
    data?: {
        [key: string]: any;
    };
    processText?: string;
    keyphraseText?: string;
    synonymText?: string;
    systemSlotText?: string;
    /** The flow parent id, something like "562fa3970685448ac241fa1f8978e496" */
    flowId?: string;
    /** The type of the sentence */
    type?: "Statement" | string;
    /** The slots matched witin the text of the user */
    slots?: any;
    /** The cognigy system slots matched witin the text of the user, as detailed object with value, offset, ... */
    detailedSlots?: any;
    /** The current state */
    state?: string;
    /** The userId of the user */
    userId?: string;
    /** The current id of this session, something like "2c44d1d3-98a4-469e-91c4-186298e22e5b" */
    sessionId?: string;
    /** Unique id of this input, something like "20ec9ed0-6f8e-4bfa-82fb-28f58be57035" */
    inputId?: string;
    /** Token tree from NLU service */
    tokens?: any;
    /** The name of the intent that was found */
    intent?: string;
    /** The score of the intent in case an intent was found */
    intentScore?: number;
    /** The name of the intent that was found but that is only allowed within a different state */
    intentOutOfState?: string;
    /** What is the stencen to clarify? */
    intentClarification?: string;
    /** The full results of our intent mapper */
    intentMapperResults?: any;
    /** The parent id of the flow that contains the winning intent, something like "6d200e6e7a6fa4549308b44b20f5217e" */
    intentFlow?: string;
    /** An object containing the current time in a fine-granular fashion */
    currentTime?: any;
    /** The mode of this input */
    mode?: "TextOnly" | "DataOnly" | "TextData" | "Empty";
    /** Identified entities */
    entities?: any;
    /** The furstation index of the user, larger than 1 */
    frustration?: number;
    /** Holds an array of noun components */
    nounComponents?: any;
    question?: any;
    /** The users channel */
    channel?: "adminconsole" | "facebook" | "google" | "twilio" | "line" | string;
    /** If an attached flow was executed, store the parent id here */
    executedAttachedFlow?: string;
    /** Was an intent or keyphrase found? */
    foundKeyphraseOrIntent?: boolean;
    /** Array of completed goals in this session */
    completedGoals?: string[];
    /** The number of executions */
    execution?: number;
    /** Was an intent or keyphrase found? */
    understood?: boolean;
    /** the language of the flow */
    language?: string;
    /**
     * DEPRECATED!!!!
     */
    currentState?: string;
    keyphrases?: any;
    numbers?: any;
    granularIntention?: string;
    granularIntentionFlow?: string;
    granularIntentionFiltered?: boolean;
    timeReference?: any;
    parsedTime?: any;
}
export interface ISensitiveLoggingSettings {
    maskLogging: boolean;
    maskAnalytics: boolean;
    disableConversations: boolean;
}
export interface IAddConditionalEntrypointParams {
    entrypoint: string;
    retentionTime: number;
    condition: string;
}
export declare type TNodeChildConfigs = {
    id: string;
    type: string;
    config: {
        [key: string]: unknown;
    };
};
export interface ICognigyInputProperties {
    /** The original text of the user */
    text?: string;
    /** The name of the intent that was found */
    intent?: string;
    /** The score of the intent in case an intent was found */
    intentScore?: number;
    /** The parent id of the flow that contains the winning intent, something like "6d200e6e7a6fa4549308b44b20f5217e" */
    intentFlow?: string;
    /** The slots matched witin the text of the user */
    slots?: any;
    /**Contains the detailed NLU processing results. */
    nlu?: {
        /** The full results of our intent mapper */
        intentMapperResults?: any;
        reconfirmationInProgress?: boolean;
        /** A unique id assigned to the flow containing the selected intent*/
        intentFlow?: string;
        /** A unique id assigned to the intent that was selected by the NLU*/
        intentId?: string;
        /** Contains the detected slots ranging from automatic to custom lexicon libraries.*/
        detailedSlots?: any;
        /** Provides an array containing each word of the input sentence as a string element.*/
        tokens?: string[];
    };
    /** The mode of this input */
    mode?: "TextOnly" | "TextData" | "DataOnly" | "Empty";
    /** The type of the sentence */
    type?: "Statement" | "Command" | "Greeting" | "BGreeting" | "whQuestion" | "howQuestion" | "ynQuestion" | "pAnswer" | "nAnswer" | string;
    /** States if a question was received as the input text and what type of question was asked.*/
    question?: any;
    /** If a state is active, this property contains the detected intent that has been excluded by the state.*/
    intentOutOfState?: string;
    /** An object containing the current time in a fine-granular fashion */
    currentTime?: {
        year?: number;
        month?: number;
        day?: number;
        hour?: number;
        minute?: number;
        second?: number;
        milliseconds?: number;
        weekday?: number;
        dayOfWeek?: string;
        ISODate?: string;
        plain?: string;
        grain?: string;
        timezoneOffset?: string;
    };
    hashedIp?: string;
    /** The current state */
    state?: string;
    /** The users channel */
    channel?: string;
    /** The type of endpoint through which the message was recieved.*/
    endpointType?: string;
    /** The flow node id that will receive and process the input object.*/
    entryPoint?: string;
    /** The userId of the user */
    userId?: string;
    /** Unique id of this input, something like "20ec9ed0-6f8e-4bfa-82fb-28f58be57035".*/
    inputId?: string;
    /** The current id of this session, something like "2c44d1d3-98a4-469e-91c4-186298e22e5b" */
    sessionId?: string;
    /** The name of the active flow which will process the input data and decide the next action to take.*/
    flowName?: string;
    /** A unique ID used to identify the specific endpoint .*/
    URLToken?: string;
    /** A score for how many misunderstood message have been received by the NLU since the last understood message*/
    frustration?: number;
    /**  An object containing the names of the goals completed on execution of the flow logic.*/
    completedGoals?: string[];
    /** The number of messages received so far in the current session. The number of messages received so far in the current session. */
    execution?: number;
    /** The original data of the user.*/
    data?: {
        [key: string]: any;
    };
    /** Was an intent or keyphrase found?*/
    understood?: boolean;
    /** The locale language that was used to process the input message.*/
    language?: string;
    /** A unique identifier for the specific user input.*/
    traceId?: string;
    /** The unique ID for the current locale used to process the input message.*/
    localeId?: string;
    /**  A boolean variable that displays "true" if the flow was executed on a conditional node.*/
    conditionalEntryPointWasExecuted?: boolean;
    [key: string]: any;
}
export interface ICognigyContactProfileProperties {
    firstname?: string;
    lastname?: string;
    email?: string;
    age?: number;
    birthday?: string;
    gender?: string;
    location?: string;
    profilepic?: string;
    prevent_data_collection?: boolean;
    accepted_gdpr?: boolean;
    goals?: string[];
    [key: string]: any;
}
declare type THttpRequestMethod = "get" | "GET" | "head" | "HEAD" | "options" | "OPTIONS" | "post" | "POST" | "put" | "PUT" | "patch" | "PATCH" | "purge" | "PURGE" | "link" | "LINK" | "unlink" | "UNLINK";
export interface IResolverParams {
    config: {
        [key: string]: any;
    };
    api: IHttpExecutionApi;
}
export interface IHttpExecutionApi {
    httpRequest?: (params: IHttpExecutionApiRequestParams) => Promise<IHttpExecutionApiRequestResponse>;
}
export interface IHttpExecutionApiRequestParams {
    method: THttpRequestMethod;
    url: string;
    data?: {
        [key: string]: any;
    };
    headers?: {
        [key: string]: any;
    };
    [key: string]: any;
}
export interface IHttpExecutionApiRequestResponse {
    status: number;
    statusText: string;
    headers?: {
        [key: string]: any;
    };
    data?: {
        [key: string]: any;
    };
}
export interface IOptionsResolverReturnData {
    label: string;
    value: string;
}
export declare type TResolverFunction = (params: IResolverParams) => Promise<IOptionsResolverReturnData[]>;
export declare type TOptionsResolverSet = (keyof IResolverParams["config"])[];
export interface INodeOptionsResolver {
    /**
     * A list of field keys.
     * The values for these fields will be available to the `resolverFunction` as the `config` parameter
     */
    dependencies: TOptionsResolverSet;
    /**
     * Function that resolves options that should be used for a distinct select field.
     *
     * The resolved options should be an array of objects with a `label` and `value` property each.
     * After returning resolved options, they will be validated with a schema, invalid responses will be ignored.
     *
     * The `config` parameter will contain the values of all fields marked in the `dependencies` array.
     * The `api` parameter provides a `httpRequest` method which follows the http proxy rules configured in the installation.
     */
    resolverFunction: TResolverFunction;
}
export {};
